from __future__ import annotations

from collections.abc import Callable
from types import ModuleType
from typing import Any, TypedDict, TypeVar, Generic, overload

from typing_extensions import Literal, ParamSpec, TypeAlias, Unpack

from paddle.static import BuildStrategy, InputSpec, Program
from .translated_layer import TranslatedLayer
from paddle.nn import Layer

_RetT = TypeVar("_RetT")
_InputT = ParamSpec("_InputT")
Backends: TypeAlias = Literal["CINN"]

class _SaveLoadConfig(TypedDict):
    output_spec: Any
    with_hook: Any
    combine_params: Any
    clip_extra: Any
    skip_forward: Any
    input_names_after_prune: Any
    skip_prune_program: Any

class ConcreteProgram: ...

class StaticFunction(Generic[_InputT, _RetT]):
    def __init__(
        self, function: Callable[_InputT, _RetT], input_spec: list[InputSpec] | None = None, **kwargs: Any
    ) -> None: ...
    def _get_debug_name(self) -> str: ...
    @property
    def is_property(self) -> bool: ...
    def train(self) -> None: ...
    def eval(self) -> None: ...
    def _clone(self) -> StaticFunction[_InputT, _RetT]: ...
    def __call__(self, *args: _InputT.args, **kwargs: _InputT.kwargs) -> _RetT: ...
    def _is_train_mode(self) -> bool: ...
    def _call_dygraph_function(self, *args: _InputT.args, **kwargs: _InputT.kwargs) -> _RetT: ...
    def _raise_when_property(self) -> None: ...
    def get_concrete_program(self, *args: _InputT.args, **kwargs: _InputT.kwargs) -> ConcreteProgram: ...
    def get_concrete_program_with_cache_key(self, cached_key: Any) -> ConcreteProgram: ...
    def get_traced_count(self) -> int: ...
    @property
    def code(self) -> str: ...
    @property
    def dygraph_function(self) -> Callable[_InputT, _RetT]: ...
    @property
    def concrete_program(self) -> ConcreteProgram: ...
    def concrete_program_specify_input_spec(
        self, input_spec: list[InputSpec] | None = None, with_hook: bool = False, is_prim_infer: bool = False
    ) -> ConcreteProgram: ...
    def rollback(self) -> Callable[_InputT, _RetT]: ...
    @property
    def inputs(self) -> list[Any]: ...
    @property
    def outputs(self) -> list[Any]: ...
    @property
    def main_program(self) -> Program: ...
    @property
    def program_cache(self) -> Any: ...
    @property
    def function_spec(self) -> Any: ...

@overload
def to_static(
    function: Layer,
    input_spec: InputSpec | None = ...,
    build_strategy: BuildStrategy | None = ...,
    backend: Backends | None = ...,
    **kwargs: Any,
) -> Layer: ...
@overload
def to_static(
    function: Callable[_InputT, _RetT],
    input_spec: InputSpec | None = ...,
    build_strategy: BuildStrategy | None = ...,
    backend: Backends | None = ...,
    **kwargs: Any,
) -> StaticFunction[_InputT, _RetT]: ...
def not_to_static(func: Callable[_InputT, _RetT] | None = None) -> Callable[_InputT, _RetT]: ...
def enable_to_static(enable_to_static_bool: bool) -> None: ...
def ignore_module(modules: list[ModuleType]) -> None: ...
def set_code_level(level: int = 100, also_to_stdout: bool = False) -> None: ...
def set_verbosity(level: int = 0, also_to_stdout: bool = False) -> None: ...
def save(
    layer: Callable[_InputT, _RetT],
    path: str,
    input_spec: InputSpec | None = None,
    **configs: Unpack[_SaveLoadConfig],
) -> None: ...
def load(path: str, **configs: Unpack[_SaveLoadConfig]) -> TranslatedLayer: ...
