from __future__ import annotations

from typing import Any, Optional

from .. import Tensor
from ..fluid.data_feeder import check_dtype as check_dtype
from ..fluid.data_feeder import check_type as check_type
from ..fluid.data_feeder import check_variable_and_dtype as check_variable_and_dtype
from ..fluid.data_feeder import convert_dtype as convert_dtype
from ..fluid.dygraph.inplace_utils import (
    inplace_apis_in_dygraph_only as inplace_apis_in_dygraph_only,
)
from ..fluid.framework import in_dygraph_mode as in_dygraph_mode
from ..fluid.layer_helper import LayerHelper as LayerHelper
from ..fluid.layers import abs as abs
from ..fluid.layers import acos as acos
from ..fluid.layers import acosh as acosh
from ..fluid.layers import asin as asin
from ..fluid.layers import asinh as asinh
from ..fluid.layers import atan as atan
from ..fluid.layers import atanh as atanh
from ..fluid.layers import ceil as ceil
from ..fluid.layers import ceil_ as ceil_
from ..fluid.layers import cos as cos
from ..fluid.layers import cosh as cosh
from ..fluid.layers import elementwise_sub as elementwise_sub
from ..fluid.layers import erf as erf
from ..fluid.layers import exp as exp
from ..fluid.layers import exp_ as exp_
from ..fluid.layers import expm1 as expm1
from ..fluid.layers import floor as floor
from ..fluid.layers import floor_ as floor_
from ..fluid.layers import lgamma as lgamma
from ..fluid.layers import log as log
from ..fluid.layers import multiplex as multiplex
from ..fluid.layers import reciprocal as reciprocal
from ..fluid.layers import reciprocal_ as reciprocal_
from ..fluid.layers import reduce_prod as reduce_prod
from ..fluid.layers import round as round
from ..fluid.layers import round_ as round_
from ..fluid.layers import rsqrt as rsqrt
from ..fluid.layers import rsqrt_ as rsqrt_
from ..fluid.layers import scale as scale
from ..fluid.layers import sin as sin
from ..fluid.layers import sinh as sinh
from ..fluid.layers import sqrt as sqrt
from ..fluid.layers import sqrt_ as sqrt_
from ..fluid.layers import square as square
from ..fluid.layers import stanh as stanh
from ..fluid.layers import tan as tan
from ..fluid.layers.layer_function_generator import (
    generate_activation_fn as generate_activation_fn,
)
from ..fluid.layers.layer_function_generator import (
    generate_layer_fn as generate_layer_fn,
)
from ..framework import convert_np_dtype_to_dtype_ as convert_np_dtype_to_dtype_
from ..framework import core as core

def scale_(
    x: Any,
    scale: float = ...,
    bias: float = ...,
    bias_after_scale: bool = ...,
    act: Optional[Any] = ...,
    name: Optional[Any] = ...,
): ...
def pow(x: Any, y: Any, name: Optional[Any] = ...): ...

OP_NAMEMAPPING: Any

def add(x: Any, y: Any, name: Optional[Any] = ...): ...
def add_(x: Any, y: Any, name: Optional[Any] = ...): ...
def subtract(x: Any, y: Any, name: Optional[Any] = ...): ...
def subtract_(x: Any, y: Any, name: Optional[Any] = ...): ...
def divide(x: Any, y: Any, name: Optional[Any] = ...): ...
def floor_divide(x: Any, y: Any, name: Optional[Any] = ...): ...
def remainder(x: Any, y: Any, name: Optional[Any] = ...): ...

mod = remainder
floor_mod = remainder

def multiply(x: Any, y: Any, name: Optional[Any] = ...): ...
def maximum(x: Any, y: Any, name: Optional[Any] = ...): ...
def minimum(x: Any, y: Any, name: Optional[Any] = ...): ...
def fmax(x: Any, y: Any, name: Optional[Any] = ...): ...
def fmin(x: Any, y: Any, name: Optional[Any] = ...): ...

proto_dict: Any
op_proto: Any
additional_args_lines: Any

def sum(
    x: Any, axis: Optional[Any] = ..., dtype: Optional[Any] = ..., keepdim: bool = ..., name: Optional[Any] = ...
): ...
def nansum(
    x: Any, axis: Optional[Any] = ..., dtype: Optional[Any] = ..., keepdim: bool = ..., name: Optional[Any] = ...
): ...
def nanmean(x: Any, axis: Optional[Any] = ..., keepdim: bool = ..., name: Optional[Any] = ...): ...
def add_n(inputs: Any, name: Optional[Any] = ...): ...
def trunc(input: Any, name: Optional[Any] = ...): ...
def mm(input: Any, mat2: Any, name: Optional[Any] = ...): ...
def addmm(input: Any, x: Any, y: Any, beta: float = ..., alpha: float = ..., name: Optional[Any] = ...): ...
def renorm(x: Any, p: Any, axis: Any, max_norm: Any): ...
def inner(x: Any, y: Any, name: Optional[Any] = ...): ...
def outer(x: Any, y: Any, name: Optional[Any] = ...): ...
def logsumexp(x: Any, axis: Optional[Any] = ..., keepdim: bool = ..., name: Optional[Any] = ...): ...
def inverse(x: Tensor, name: Optional[str] = ...) -> Tensor: ...
def max(x: Any, axis: Optional[Any] = ..., keepdim: bool = ..., name: Optional[Any] = ...): ...
def min(x: Any, axis: Optional[Any] = ..., keepdim: bool = ..., name: Optional[Any] = ...): ...
def amax(x: Any, axis: Optional[Any] = ..., keepdim: bool = ..., name: Optional[Any] = ...): ...
def amin(x: Any, axis: Optional[Any] = ..., keepdim: bool = ..., name: Optional[Any] = ...): ...
def log1p(x: Any, name: Optional[Any] = ...): ...
def log2(x: Any, name: Optional[Any] = ...): ...
def log10(x: Any, name: Optional[Any] = ...): ...
def clip(x: Any, min: Optional[Any] = ..., max: Optional[Any] = ..., name: Optional[Any] = ...): ...
def clip_(x: Any, min: Optional[Any] = ..., max: Optional[Any] = ..., name: Optional[Any] = ...): ...
def trace(x: Any, offset: int = ..., axis1: int = ..., axis2: int = ..., name: Optional[Any] = ...): ...
def diagonal(x: Any, offset: int = ..., axis1: int = ..., axis2: int = ..., name: Optional[Any] = ...): ...
def kron(x: Any, y: Any, name: Optional[Any] = ...): ...
def cumsum(x: Any, axis: Optional[Any] = ..., dtype: Optional[Any] = ..., name: Optional[Any] = ...): ...
def cumprod(x: Any, dim: Optional[Any] = ..., dtype: Optional[Any] = ..., name: Optional[Any] = ...): ...
def isfinite(x: Any, name: Optional[Any] = ...): ...
def isinf(x: Any, name: Optional[Any] = ...): ...
def isnan(x: Any, name: Optional[Any] = ...): ...
def prod(
    x: Any, axis: Optional[Any] = ..., keepdim: bool = ..., dtype: Optional[Any] = ..., name: Optional[Any] = ...
): ...
def sign(x: Any, name: Optional[Any] = ...): ...
def tanh(x: Tensor, name: Optional[Any] = ...) -> Tensor: ...
def tanh_(x: Tensor, name: Optional[Any] = ...) -> Tensor: ...
def increment(x: Any, value: float = ..., name: Optional[Any] = ...): ...
def all(x: Any, axis: Optional[Any] = ..., keepdim: bool = ..., name: Optional[Any] = ...): ...
def any(x: Any, axis: Optional[Any] = ..., keepdim: bool = ..., name: Optional[Any] = ...): ...
def broadcast_shape(x_shape: Any, y_shape: Any): ...
def conj(x: Any, name: Optional[Any] = ...): ...
def digamma(x: Any, name: Optional[Any] = ...): ...
def neg(x: Any, name: Optional[Any] = ...): ...
def atan2(x: Any, y: Any, name: Optional[Any] = ...): ...
def logit(x: Any, eps: Optional[Any] = ..., name: Optional[Any] = ...): ...
def lerp(x: Any, y: Any, weight: Any, name: Optional[Any] = ...): ...
def lerp_(x: Any, y: Any, weight: Any, name: Optional[Any] = ...): ...
def erfinv(x: Any, name: Optional[Any] = ...): ...
def erfinv_(x: Any, name: Optional[Any] = ...): ...
def rad2deg(x: Any, name: Optional[Any] = ...): ...
def deg2rad(x: Any, name: Optional[Any] = ...): ...
def gcd(x: Any, y: Any, name: Optional[Any] = ...): ...
def lcm(x: Any, y: Any, name: Optional[Any] = ...): ...
def diff(
    x: Any,
    n: int = ...,
    axis: int = ...,
    prepend: Optional[Any] = ...,
    append: Optional[Any] = ...,
    name: Optional[Any] = ...,
): ...
def angle(x: Any, name: Optional[Any] = ...): ...
