from __future__ import annotations

from typing import Any, Optional

def create_tensor(dtype: Any, name: Optional[str] = ..., persistable: bool = ...): ...
def create_parameter(
    shape: Any,
    dtype: Any,
    name: Optional[str] = ...,
    attr: Optional[Any] = ...,
    is_bias: bool = ...,
    default_initializer: Optional[Any] = ...,
): ...
def create_global_var(
    shape: Any, value: Any, dtype: Any, persistable: bool = ..., force_cpu: bool = ..., name: Optional[str] = ...
): ...
def cast(x: Any, dtype: Any): ...
def concat(input: Any, axis: int = ..., name: Optional[str] = ...): ...
def tensor_array_to_tensor(input: Any, axis: int = ..., name: Optional[str] = ..., use_stack: bool = ...): ...
def sums(input: Any, out: Optional[Any] = ...): ...
def assign(input: Any, output: Optional[Any] = ...): ...
def fill_constant(
    shape: Any, dtype: Any, value: Any, force_cpu: bool = ..., out: Optional[Any] = ..., name: Optional[str] = ...
): ...
def fill_constant_batch_size_like(
    input: Any,
    shape: Any,
    dtype: Any,
    value: Any,
    input_dim_idx: int = ...,
    output_dim_idx: int = ...,
    force_cpu: bool = ...,
): ...
def argmin(x: Any, axis: int = ...): ...
def argmax(x: Any, axis: int = ...): ...
def argsort(input: Any, axis: int = ..., descending: bool = ..., name: Optional[str] = ...): ...
def ones(shape: Any, dtype: Any, force_cpu: bool = ...): ...
def zeros(shape: Any, dtype: Any, force_cpu: bool = ..., name: Optional[str] = ...): ...
def reverse(x: Any, axis: Any): ...
def has_inf(x: Any): ...
def has_nan(x: Any): ...
def isfinite(x: Any): ...
def range(start: Any, end: Any, step: Any, dtype: Any, name: Optional[str] = ...): ...
def linspace(start: Any, stop: Any, num: Any, dtype: Optional[Any] = ..., name: Optional[str] = ...): ...
def zeros_like(x: Any, out: Optional[Any] = ...): ...
def diag(diagonal: Any): ...
def eye(
    num_rows: Any,
    num_columns: Optional[Any] = ...,
    batch_shape: Optional[Any] = ...,
    dtype: str = ...,
    name: Optional[str] = ...,
): ...
def ones_like(x: Any, out: Optional[Any] = ...): ...
def triu(input: Any, diagonal: int = ..., name: Optional[str] = ...): ...
