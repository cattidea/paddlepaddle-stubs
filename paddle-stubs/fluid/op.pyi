from __future__ import annotations

from typing import Any

def get_all_op_protos(): ...
def is_str(s: Any): ...

class OpDescCreationMethod:
    __op_proto__: Any = ...
    def __init__(self, op_proto: Any) -> None: ...
    def __call__(self, *args: Any, **kwargs: Any): ...
    @staticmethod
    def any_is_true(generator: Any): ...

class OpInfo:
    name: Any = ...
    method: Any = ...
    inputs: Any = ...
    outputs: Any = ...
    attrs: Any = ...
    def __init__(self, name: Any, method: Any, inputs: Any, outputs: Any, attrs: Any) -> None: ...

def create_op_creation_method(op_proto: Any): ...

class OperatorFactory:
    op_methods: Any = ...
    def __init__(self) -> None: ...
    def __call__(self, *args: Any, **kwargs: Any): ...
    def types(self): ...
    def get_op_info(self, t: Any): ...
    def get_op_input_names(self, type: Any): ...
    def get_op_inputs(self, type: Any): ...
    def get_op_output_names(self, type: Any): ...
    def get_op_outputs(self, type: Any): ...
    def get_op_attr_names(self, type: Any): ...

class __RecurrentOp__:
    __proto__: Any = ...
    type: str = ...
    def __init__(self) -> None: ...
    def __call__(self, *args: Any, **kwargs: Any): ...

class __DynamicRecurrentOp__:
    __proto__: Any = ...
    type: str = ...
    def __init__(self) -> None: ...
    def __call__(self, *args: Any, **kwargs: Any): ...

class __CondOp__:
    __proto__: Any = ...
    type: str = ...
    def __init__(self) -> None: ...
    def __call__(self, *args: Any, **kwargs: Any): ...

Operator: Any
RecurrentOp: Any
DynamicRecurrentOp: Any
CondOp: Any
